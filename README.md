# Мои исходные файлы по изучению языка c++

Заметки по c++

&& - и<br>
|| - или<br>
! - не

# TASK
Написать алгортим для расчета ближайшего лифта к человек 
<br><a href="https://github.com/kondrash228/learn-cpp/blob/master/elevators.cpp">попытки это сделать</a><br> 

# Random Numbers
Для того что бы сгенерировать или заполнить массив случайными числами, нужно ОДИН раз вызвать функцию srand(time(NULL)); не забываем подключить библиотеку "ctime"; далее вызывая функцию rand() % 10 - (генерируем случайные числа от 1 до 10); будут генерироваться каждый раз случайные числа

# Прототипы функций
Создание функции в начале программы - прототип функции
<br><a href="https://github.com/kondrash228/learn-cpp/blob/master/prototypes">перейти в пример</a><br> 

# Перегрузка функций
Чем больше реализаций функции, тем больше перегрузка функции
<br><a href="https://github.com/kondrash228/learn-cpp/blob/master/overload">перейти в пример</a><br> 

# Шаблонный функции
Шаблонные функции - template <typename T> “далее функция” (принимает любые типы)
<br><a href="https://github.com/kondrash228/learn-cpp/blob/master/template">перейти в пример</a><br> 
  
# Стек
Стек вызовов - последний зашел, первый вышел 

# Указатели
Указатель - *p”имя переменной” = &(взятие адреса)”переменная на которую указываем”, тип данных указателя должен соответствовать типу данных на который он указывает, что бы разыменовать переменную (получить ее значение с указателя), нужно поставить звездочку(*); Что бы изменить значение переменной через указатель, сначала нужно разыменовать его. Можно объявить и не присваивать ему значение; Принимает значение NULL, nullptr, 0; в отличие от ссылки; Если функция принимает указатель, то когда мы при вызове функции передаем аргумент нам нужно взять адрес того что мы передаем. Пример - Foo(&a);
<br><a href="https://github.com/kondrash228/learn-cpp/blob/master/pointers">перейти в пример</a><br> 
  
# Арифметика указателей
Пример - см.папку pointers в c++
<br><a href="https://github.com/kondrash228/learn-cpp/blob/master/dynamic%20memory/null/nullptr.cpp">перейти в пример</a><br> 

# Имя масиива (указатель)
Имя массива это и есть указатель на его первый элемент, если к нему (указателю) прибавить столько байт сколько вести один его элемент (нужно прибавлять элемент такого же типо как и массив)  то сдвинемся на следующий его массив. Пример - *(arr(имя массива) + 1) - сдвигаемся на второй элемент массива; при условии что массив состоит из элементов типа int
<br><a href="https://github.com/kondrash228/learn-cpp/blob/master/arrays">перейти в пример</a><br> 
  
# Cсылки 
Пример - &aRef = a; (это ссылка на переменную а); У ссылок не оператора разыменования, через ссылку мы работаем с данными (в примере с переменной а);
Различие между ссылкой и указателем: мы не можем объявить ссылку и не присвоить ей значение в отличие от указателя; Не принимает значение NULL, nullptr, 0;
<br><a href="https://github.com/kondrash228/learn-cpp/blob/master/links">перейти в пример</a><br> 

# Динамическая память 
Операторы выделения памяти new и delete. Пример  - int *pa = new int; (создаем указатель pa; и с помощью слова new выделяем память вне нашей программы, типа int). Язык c++ не имеет сборщика мусора как некоторые другие языки (java, c#); соответственно после того как мы провели какие то операции над указателем, нам нужно очистить место в оперативной памяти компьютера, с помощью ключевого слова delete. Пример delete pa; ВСЕГДА после того как мы выделили память нужно ее ОЧИСТИТЬ; Что бы избежать утечки памяти (выделили память и не почистили). 
<br><a href="https://github.com/kondrash228/learn-cpp/blob/master/dynamic%20memory/new/new.cpp">перейти в пример</a><br> 

# NULL и nullptr
Разница между NULL и nullptr - компилятор никогда не перепутает его с целочисленным типом данных (int). Если мы захотим очистить динамическую память, то сначала нужно вызвать delete, а потом затирать адрес через NULL или nullptr.
<br><a href="https://github.com/kondrash228/learn-cpp/blob/master/dynamic%20memory/null/nullptr.cpp">перейти в пример</a><br> 

# Dynamic arrays
Для того что бы создать динамическй массив, нужно использовать указатель, ключевое слово new, и в конце нужно очистить память с помощью delete [] arr; Если массив является динамическим, то он будет находиться в динамической памяти
<br><a href="https://github.com/kondrash228/learn-cpp/blob/master/dynamic%20memory/arrays">перейти в пример</a><br> 
 
# Double Dynamic Arrays
Для того что бы создать двойной динмический массив, нужно использовать следующую конструкцию - int **arr = new int* [rows]; и создается массив указателей
<br><a href="https://github.com/kondrash228/learn-cpp/blob/master/dynamic%20memory/arrays">перейти в пример</a><br> 

# Copy Dynamic Arrays
Массив - это указатель, который указывает на место в динмической памяти, где хранятся ячейки с элементами массива. Если создать 2 массива: array1 и array2, и произвести следующую операцию: array1 = array2; то array1 станет указателем на array2, а свои старые значения он потеряет и они так и останутся висеть в динамичсекой памяти